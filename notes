Computational Chemistry Programmin Project

Inés Sánchez de Movellán

04/11/2020
- Programming language: FORTRAN 90
- Monte Carlo algorithm for displacements
- Serial code version
- Then: paralelization and molecular dynamics simulation

- Read information
- Create github repository to upload the code
- Create a main program main.f90
- Create a module to perform the simulation
- Create a makefile to compile and execute the code
Inside the module, we have create the initial_geom(n,L,geom0) subroutine, which allows to create
the initial geometry of the system setting (at least now) a random distribution of the particles.
The geometry is written in an xyz file that could be read with avogadro. On the other hand,
we have done an algorithim with 2 do loops to calculate the square of the inter-particle 
distance among all particles. To do that, we store the distances in a matrix in which the
off diagonal elements are zero: 
r12 r13 r14 r15 ... r1n
0   r23 r24 r25 ... r2n
0   0   r34 r35 ... r3n
0   0    0   :       :
:   :    :   :       :
0   0    0   0  ... rnn

05/11/2020
In the same subroutine (energy) we have computed the value of r**12 and r**6 which will be
used to obtain the potential energy. We computed the intial values of these powers of the 
distance and the initial potential energy. Then, the Monte Carlo algorithm (a initial version of
it) starts. We have defined a maximun number of cycles (chosen by the user) and a threshold in
the energy change (also chosen by the user). Inside the do while loop of the MC, we chose
a random atom and displaced it, we compute the energy and the energy diference between it
and the previous geometry and, if delta_V is less than 0 the displacement is accepted. When 
delta_V is positive, we evaluate the boltzmann factor and compare it to a random number between
0 and 1. If random is less than exp(-delta_V) the displacement is accepted and a new cycle
with the new geometry starts, if not, a new cycle with the previous geometry starts. 

09/11/2020
Organization of the code: three subroutines in the module: one to set the initial geom, another
which allows to compute the energy for a geometry of the particles (this subroutine will compute
the energy with PBC) and the last one performs the montecarlo, it calls the subroutine energy
on each montecarlo cycle.

10/11/2020
Monte Carlo subroutine is complete, the temperature is included in reduce units 300K = 1.268 RU. 
Everything seems to work well when the values are T = 1.268 and N = 200. We have to compute
the autocorrelation function g(r), but the potential energy converges to the same energy, with
some oscillations, for different initial geometries. 

26/11/2020
We have implemented in MC subroutine an algorithm to calculate the pair correlation function,
which have some wrong constants but the shape is similar to the expected one, it is not 
soft and I have to solve it. 

01/11/2020, not uploaded yet
I have implemented a new way to compute the deltaV, directly, instead of computing the whole r2  
matrix and the overall V on each MonteCarlo. There is a discrepancy between both results and     
it comes from the Vrc cause if I do not include this Vrc the problem vanishes. The discrepancy   
appears again when I increase the number of monte carlo cycles but I think that it is            
because I only take one deltaV of reference. I will contruct two LJfluid modules, one with the   
overall V subroutine and one with deltaV subroutine and, for the same geometry I will check the  
results.                                                                                         

02/11/2020
I rewrite the way to implement PBC with the nearest convention image. I have reduced the 
number of if-else structures I use from 8 to 3. I just implemented it in initial_energy
subroutine cause the delta_energy subroutine it is not working yet.
The implementation of PBC have been also included in delta_pot subroutine, providing the same 
results as initial_V subroutine for 1 montecarlo cycle. The next step is to solve the problem 
in potential for larger montecarlo cycles

03/11/2020
The subroutine to compute only deltaV on each montecarlo step is implemented and works properly.
The shape of the function g(r) is not correct at all, it is not smooth. The code is now stetic and
easy to read, and properly docummented.
